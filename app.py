from flask import Flask, render_template, request, jsonify
import os
import json
import threading
import pyttsx3
import requests
from vosk import Model, KaldiRecognizer
from word2number import w2n
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import pyaudio
import logging

app = Flask(__name__)

# Initialize logging
logging.basicConfig(level=logging.INFO)

# Initialize variables
model_path = r"C:\Users\nagpakab\OneDrive - Merck Sharp & Dohme LLC\Documents\vosk-model-en-us-0.42-gigaspeech"
transcription_file = "transcription.txt"
checklist_file = "checklist_responses.txt"
user_email = None
is_listening = False
recording = False
checklist_index = 0
responses = []

# Initialize Vosk model and recognizer
model = Model(model_path)
rec = KaldiRecognizer(model, 16000)

# Initialize audio input
p = pyaudio.PyAudio()
stream = None

# Initialize text-to-speech engine
engine = pyttsx3.init()
engine_lock = threading.Lock()

# Checklist items
checklist = [
    ("Raw materials were used within expiry or use by or re-evaluation or recertification date.", "boolean"),
    ("Training was complete as per batch records or process requirements.", "boolean"),
    ("No major changes to batch record without quality approval.", "boolean"),
    ("Batch has been manufactured following cGMPs and all batch documentation has been reviewed.", "boolean"),
    ("AQL passed, if performed during manufacturing.", "boolean"),
    ("Deviations or NOEs?", "boolean"),
    ("Are all raw materials fully released?", "boolean"),
    ("The date of manufacture is recorded on the cover page of the batch record.", "boolean"),
    ("Confirmed identification of major equipment and asset numbers. Verified all fields are filled in as appropriate and equipment was used within its qualified parameters.", "boolean"),
    ("All scales and balances IDs and calibration statuses are recorded.", "boolean"),
    ("Manufacturing Procedures: confirmed start and stop times, processing times are chronologically correct within established time limits as applicable, and the performed by/ checked by / verified by fields are complete.", "boolean"),
    ("All in-processes measurements met specified setpoints or ranges.", "boolean"),
    ("Environmental data meets the specified limits (if applicable).", "boolean"),
    ("Personnel / Signature Log. All Personnel involved in batch manufacture or review are listed on the signature log.", "boolean"),
    ("All deviations, planned deviations, change controls, and risk use for the batch were identified and documented. All material and batch numbers are listed.", "boolean"),
    ("There are no blank data entry spaces as per Sop-20688.", "boolean"),
    ("Any units delivered to inventory in the batch record agrees with the amount entered during Goods Receipt.", "boolean"),
    ("Label information corresponds to information in the batch record. All label reconciliations are complete as per SOP 958-1039 applicable forms.", "boolean"),
    ("Calculations performed and verified or checked by two different individuals, except data generated by a validated system (one signature required).", "boolean")
]

conditional_questions = {
    6: [("If No, list materials that are not fully released.", "text"), ("For risk used batches/materials which are imported to the US only, notifications of the FDA release received.", "text")],
    5: [("If Yes, Batch Impact? PR# 70522 90635 and 90647.", "text")]
}

# Helper functions
def open_stream():
    global stream
    if stream is None or not stream.is_active():
        stream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=4096)
    return stream

def close_stream():
    global stream
    if stream is not None:
        stream.stop_stream()
        stream.close()
        stream = None

def speak(text):
    with engine_lock:
        engine.say(text)
        engine.runAndWait()

def post_process_text(text):
    digit_map = {
        "zero": "0", "one": "1", "two": "2", "three": "3", "four": "4",
        "five": "5", "six": "6", "seven": "7", "eight": "8", "nine": "9"
    }
    words = text.lower().split()
    if all(word in digit_map for word in words):
        return ''.join(digit_map[word] for word in words)
    try:
        return str(w2n.word_to_num(text))
    except ValueError:
        return ' '.join(digit_map.get(word, word) for word in words)

def save_response_to_file(item, response):
    with open(checklist_file, "a") as f:
        f.write(f"{item}: {response}\n")

def save_responses():
    with open(checklist_file, "w") as f:
        for item, response in responses:
            f.write(f"{item}: {response}\n")
    speak("Operations Checklist completed and saved")

# Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/submit_email', methods=['POST'])
def submit_email():
    global user_email
    user_email = request.form['email']
    logging.info(f"Received email: {user_email}")
    if user_email:
        return jsonify({'status': 'success', 'message': 'User email registered. Loading model, please wait...'})
    else:
        return jsonify({'status': 'error', 'message': 'Please enter a valid email address.'})

@app.route('/start_listening', methods=['POST'])
def start_listening():
    global is_listening
    is_listening = True
    logging.info("Starting to listen for commands...")
    thread = threading.Thread(target=listen)
    thread.start()
    return jsonify({'status': 'success', 'message': 'Listening for commands...'})

def listen():
    global is_listening, checklist_index
    checklist_index = 0
    stream = open_stream()
    logging.info("Microphone stream opened.")
    try:
        while is_listening:
            data = stream.read(4096, exception_on_overflow=False)
            if rec.AcceptWaveform(data):
                results = json.loads(rec.Result())
                text = results.get('text', '').lower()
                logging.info(f"Recognized text: {text}")
                if any(wake_word in text for wake_word in ["hey flex", "hey fleks", "hey flax", "hey fecks"]):
                    command_text = text.split("hey flex", 1)[-1].strip()
                    command_text = post_process_text(command_text)
                    logging.info(f"Command text: {command_text}")
                    speak(f"You said: {command_text}")
                    if any(phrase in command_text for phrase in ["initiate operations checklist", "start operations checklist"]):
                        speak("Initializing Operations Checklist")
                        start_checklist()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Initializing Operations Checklist', 'command': command_text})
                    elif "weather" in command_text:
                        speak("Fetching weather information...")
                        get_weather()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Fetching weather information...', 'command': command_text})
                    elif any(phrase in command_text for phrase in ["send my operations checklist", "email my operations checklist"]):
                        speak("Sending checklist via email")
                        send_email()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Sending checklist via email', 'command': command_text})
                    elif any(phrase in command_text for phrase in ["start recording", "begin recording"]):
                        start_transcription()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Started recording', 'command': command_text})
                    elif any(phrase in command_text for phrase in ["stop recording", "stop transcription"]):
                        stop_transcription()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Stopped recording', 'command': command_text})
                    elif any(phrase in command_text for phrase in ["send my recording", "email my recording"]):
                        speak("Sending transcription via email")
                        send_email_transcription()
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': 'Sending transcription via email', 'command': command_text})
                    else:
                        is_listening = True  # Reset the flag to continue listening
                        return jsonify({'status': 'success', 'message': f'Command: {command_text}', 'command': command_text})
    except Exception as e:
        logging.error(f"Error in listen function: {str(e)}")
        speak(f"Error: {str(e)}")
    finally:
        close_stream()
        logging.info("Microphone stream closed.")
        is_listening = False

@app.route('/start_checklist', methods=['POST'])
def start_checklist():
    global checklist_index, responses
    checklist_index = 0
    responses = []
    speak("Initializing Operations Checklist")
    ask_next_checklist_item()
    return jsonify({'status': 'success', 'message': 'Operations Checklist started.'})

def ask_next_checklist_item():
    global checklist_index
    if checklist_index < len(checklist):
        question, response_type = checklist[checklist_index]
        speak(question)
        threading.Thread(target=listen_for_response, args=(response_type,)).start()
    else:
        save_responses()

def listen_for_response(response_type):
    global checklist_index, responses
    stream = open_stream()
    logging.info("Microphone stream opened for checklist response.")
    try:
        while True:
            data = stream.read(4096, exception_on_overflow=False)
            if rec.AcceptWaveform(data):
                results = json.loads(rec.Result())
                text = results.get('text', '').lower()
                logging.info(f"Recognized response: {text}")

                if text in ['exit', 'quit']:
                    speak("Exiting checklist")
                    return

                if response_type == "boolean":
                    if text in ['yes', 'yeah', 'ya', 'no', 'nah', 'nope']:
                        text = post_process_text(text)
                        responses.append((checklist[checklist_index][0], text))
                        save_response_to_file(checklist[checklist_index][0], text)

                        if text in ['yes', 'yeah', 'ya']:
                            if checklist_index == 5:
                                checklist[checklist_index + 1:checklist_index + 1] = conditional_questions[5]
                        elif text in ['no', 'nah', 'nope']:
                            if checklist_index == 6:
                                checklist[checklist_index + 1:checklist_index + 1] = conditional_questions[6]

                        checklist_index += 1
                        ask_next_checklist_item()
                        return

                elif response_type == "text":
                    responses.append((checklist[checklist_index][0], text))
                    save_response_to_file(checklist[checklist_index][0], text)
                    checklist_index += 1
                    ask_next_checklist_item()
                    return

                speak("Please respond with a 'Yes' or 'No'.")
    except Exception as e:
        logging.error(f"Error in listen_for_response function: {str(e)}")
        speak(f"Error: {str(e)}")
    finally:
        close_stream()
        logging.info("Microphone stream closed for checklist response.")

def get_weather():
    url = "https://api.open-meteo.com/v1/forecast?latitude=40.611375&longitude=-74.268305&current=temperature_2m,relative_humidity_2m,precipitation,rain,showers,snowfall,wind_speed_10m,wind_direction_10m,wind_gusts_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=America%2FNew_York&forecast_days=1"

    try:
        response = requests.get(url, verify=False)
        response.raise_for_status()
        weather_data = response.json()

        current_temp = weather_data['current']['temperature_2m']
        chance_of_rain = weather_data['current']['rain']
        wind_speed = weather_data['current']['wind_speed_10m']

        speak(f"The current temperature is {current_temp} degrees Fahrenheit. The expected amount of rain is {chance_of_rain} inches. The wind speed is {wind_speed} miles per hour.")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching weather: {str(e)}")
        speak(f"Error fetching weather: {str(e)}")

def send_email():
    global user_email
    if not user_email:
        speak("User email not found. Please restart the application.")
        return

    msg = MIMEMultipart()
    msg['From'] = 'usryssnmr@merck.com'
    msg['To'] = user_email
    msg['Subject'] = "Operations Checklist"

    body = "Please find the attached checklist responses."
    msg.attach(MIMEText(body, 'plain'))

    filename = checklist_file
    attachment = open(filename, "rb")

    part = MIMEBase('application', 'octet-stream')
    part.set_payload(attachment.read())
    encoders.encode_base64(part)
    part.add_header('Content-Disposition', f"attachment; filename= {filename}")

    msg.attach(part)

    try:
        server = smtplib.SMTP('Mailhost.merck.com', 25)
        server.starttls()
        text = msg.as_string()
        server.sendmail('usryssnmr@merck.com', user_email, text)
        server.quit()
        speak("Email sent successfully!")
    except Exception as e:
        logging.error(f"Error sending email: {str(e)}")
        speak(f"Error sending email: {str(e)}")

def send_email_transcription():
    global user_email
    if not user_email:
        speak("User email not found. Please restart the application.")
        return

    msg = MIMEMultipart()
    msg['From'] = 'usryssnmr@merck.com'
    msg['To'] = user_email
    msg['Subject'] = "Transcription"

    body = "Please find the attached transcription."
    msg.attach(MIMEText(body, 'plain'))

    filename = transcription_file
    attachment = open(filename, "rb")

    part = MIMEBase('application', 'octet-stream')
    part.set_payload(attachment.read())
    encoders.encode_base64(part)
    part.add_header('Content-Disposition', f"attachment; filename= {filename}")

    msg.attach(part)

    try:
        server = smtplib.SMTP('Mailhost.merck.com', 25)
        server.starttls()
        text = msg.as_string()
        server.sendmail('usryssnmr@merck.com', user_email, text)
        server.quit()
        speak("Transcription email sent successfully!")
    except Exception as e:
        logging.error(f"Error sending email: {str(e)}")
        speak(f"Error sending email: {str(e)}")

def start_transcription():
    global recording
    if not recording:
        recording = True
        speak("Started recording")
        threading.Thread(target=record_transcription).start()

def stop_transcription():
    global recording
    if recording:
        recording = False
        speak("Stopped recording")

def record_transcription():
    global recording
    stream = open_stream()
    with open(transcription_file, 'w') as f:
        try:
            while recording:
                data = stream.read(4096, exception_on_overflow=False)
                if rec.AcceptWaveform(data):
                    results = json.loads(rec.Result())
                    text = results.get('text', '').lower()
                    f.write(text + '\n')
        except Exception as e:
            logging.error(f"Error: {str(e)}")
            speak(f"Error: {str(e)}")
        finally:
            close_stream()

if __name__ == "__main__":
    app.run(debug=True)
